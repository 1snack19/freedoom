#!/usr/bin/env perl
#
# Wadinfo builder, rewritten in perl :)
#
# Copyright (c) 2006 Simon Howard.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#   * Redistributions of source code must retain the above copyright 
#     notice, this list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright 
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of Simon Howard nor the names of its contributors
#     may be used to endorse or promote products derived from this
#     software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use strict;

my $dummy = 0;

sub findfile {
	my ($section, $name) = @_;

	my $filename = "$section/" . lc($name) . ".*";
	my @list = glob($filename);
	
	return undef if scalar @list <= 0;

	return $list[0];
}

for (my $i=0; $i<scalar @ARGV; ++$i) {
	$_ = $ARGV[$i];

	if ($_ eq '-dummy') {
		$dummy = 1;
	} 
}

print "; This file is automatically generated, do not edit it directly!\n\n";

my $section = "";

while (<STDIN>) {
	chomp;

	# remove comments

	s/[\#\;].*$//;

	# check for empty lines and comments

	# sections

	if(/\[.*\]/) {

		# extract section name

		$section = $_;
		$section =~ s/.*\[//;
		$section =~ s/\].*//;

		# catch [texture1] and [texture2] which are in 
		# textures/

		$section = "textures"
	 		if $section eq "texture1" ||
			   $section eq "texture2";

	} elsif (/^\s*(\S+)[^\=]*(\s*\=\s*(\S+))?/) {
		
        my ($resname, $override) = ($1, $3);
           
        $resname = lc($resname);

        # allow "=foo" to override the filename used

		my $filename;

        if ($override) {
            $filename = findfile($section, $override);
        } else {
            $filename = findfile($section, $resname);
        }

		if (!$filename) {
			if ($dummy) {

                # this hasnt been submitted yet - use a dummy lump
                # instead

				if ($resname =~ /^DEMO/i) {
					$_ = "$resname = fakedemo";
				} else {
					$_ = "$resname = dummy";
				}
			} else {
                # disabled entries are commented out

				$_ = ";$_";
			}
		}
	}

	print $_ . "\n";
}
